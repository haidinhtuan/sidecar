/*
  Author: Hai Dinh-Tuan
  Email: haidinhtuan@gmail.com

  This code sets up an HTTP/2 sidecar proxy that listens on port 9999. 
  It receives incoming HTTP/2 requests on clientStreams, inspects the headers, and forwards the requests to the appropriate target service based on the HTTP path and authority header.

  The code collects the request body data, logs the incoming request details, and forwards the request to the target service. 
  It then listens for the HTTP/2 response, logs the outgoing response headers, and forwards the response data back to the client on the existing clientStream.

  The target service URL is determined based on the extracted targetNf from the path. If the path does not match the expected format, an error is logged.
*/

const http2 = require('http2');

const fs = require('fs');


// Create the HTTP/2 proxy server
const proxy = http2.createServer();

console.log("Starting the HTTP/2 sidecar proxy...");

// Event handler for incoming client streams. 
proxy.on('stream', (clientStream, clientHeaders) => {
  let targetUrl;
  let method = clientHeaders[':method'];
  let path = clientHeaders[':path'];
  let requestBody = [];
  let requestBodyBinary = [];
  const contentType = clientHeaders['content-type'];


  // Handle errors in the client stream
  clientStream.on('error', (error) => {
    console.error('Error in clientStream:', error);
  });

  // Collect the request body data
  clientStream.on('data', (chunk) => {
    requestBody.push(chunk);
    requestBodyBinary.push(chunk);
  });

  let forwardRequestBodyJson;
  let hasBody = false;
  let isParsable = true;

  if (contentType && contentType.includes('multipart/related')) {
    isParsable = false;
    console.log(`This is multipart messsage`);
  }
  

  // Process the request when it ends
  clientStream.on('end', () => {

    // If it has body
    if (requestBody && requestBody.length > 0) {
      requestBody = Buffer.concat(requestBody).toString('ascii');      

      // requestBodyJson = Buffer.concat(requestBody);

      // Log the incoming request details
      console.log('============================= Incoming Request ==============================');
      console.log(`HTTP Method: ${method}`);
      console.log('Headers:', clientHeaders);
      console.log('Body:', requestBody);
      console.log('=============================================================================');
      console.log();

      //Make sure this is a valid JSON - Message (6451) AMF to SMF - Create SM Context - TS29502_Nsmf_PDUSession
      if (isParsable === true) {
        try {
          forwardRequestBodyJson = JSON.parse(requestBody);
        } catch (error) {
          console.error('Error parsing JSON:', error);
          // Handle the error accordingly
          const start = requestBody.indexOf('{');
          const end = requestBody.lastIndexOf('}');
          const extractedRequestBody = requestBody.substring(start, end + 1);
          forwardRequestBodyJson = JSON.parse(extractedRequestBody);
        }
      }
      hasBody = true;
      // No requestBody
    } else {
      // Handle the case when requestBody is empty or undefined
      // Log the incoming request details
      console.log('============================= Incoming Request ==============================');
      console.log(`HTTP Method: ${method}`);
      console.log('Headers:', clientHeaders);
      console.log('Empty Body');
      console.log('=============================================================================');
      console.log();
      hasBody = false
    }

    let targetNf;

    // Check if the request is generated by the local NF (authority = *.snet.tuberlin:9999 or 127.0.0.1:9999) or by a remote NF (different authority value)
    if (clientHeaders[':authority'] === 'localhost:9999' || clientHeaders[':authority'] === '127.0.0.1:9999' ||
      clientHeaders[':authority'].endsWith('.snet.tuberlin:9999')) {
      //if (clientHeaders[':authority'] === 'localhost:9999' || clientHeaders[':authority'] === '127.0.0.1:9999') {
      console.log(`Message generated by the local NF`);
      console.log(`Path: ${path}`);

      // Extract the targetNf from the path
      let match = path.match(/\/(\w+)-/);
      if (match && match[1]) {
        targetNf = match[1].substring(1);
        targetUrl = `http://free5gc-core-free5gc-${targetNf}-sidecar-service:9999`;
        console.log(`Target URL: ${targetUrl}`);

        // Modify the NF registration messages, filter by message sent to NRF
        if (targetNf === "nrf" && hasBody) {
          console.log('NF Registration detected! Modify the body');

          try {

            // Iterate through nfServices array and update apiPrefix and port values
            if (forwardRequestBodyJson.nfServices) {
              forwardRequestBodyJson.nfServices.forEach((nfService) => {
                if (nfService.apiPrefix) {
                  nfService.apiPrefix = nfService.apiPrefix.replace(/:\d+/, ':9999');
                }
                if (nfService.ipEndPoints) {
                  nfService.ipEndPoints.forEach((ipEndPoint) => {
                    ipEndPoint.port = 9999;
                  });
                }
              });
            }

            // Update callbackUri port in defaultNotificationSubscriptions if present
            if (forwardRequestBodyJson.defaultNotificationSubscriptions) {
              forwardRequestBodyJson.defaultNotificationSubscriptions.forEach((subscription) => {
                subscription.callbackUri = subscription.callbackUri.replace(/:\d+\//, ':9999/');
              });
            }
            console.log('New Body:')
            console.log(JSON.stringify(forwardRequestBodyJson));
          } catch (error) {
            console.error('Error parsing JSON:', error);
          }
        }
      } else {
        console.error("Invalid path format. Unable to extract targetNf.");
      }
    } else {
      targetUrl = 'http://localhost:80';
    }


    const { HTTP2_HEADER_METHOD,
      HTTP2_HEADER_CONTENT_TYPE,
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_SCHEME } = http2.constants;

    let forwardHeader;

    if (method === 'POST') {
      forwardHeader = http2.constants.HTTP2_METHOD_POST;
    } else if (method === 'GET') {
      forwardHeader = http2.constants.HTTP2_METHOD_GET;
    } else if (method === 'PUT') {
      forwardHeader = http2.constants.HTTP2_METHOD_PUT;
    } else if (method === 'PATCH') {
      forwardHeader = http2.constants.HTTP2_METHOD_PATCH;
    } else {
      // Handle other methods or set a default value if needed
    }

    const options = {
      [HTTP2_HEADER_METHOD]: forwardHeader,
      [HTTP2_HEADER_PATH]: path,
      [HTTP2_HEADER_SCHEME]: 'http',
    };
    
    if (hasBody && isParsable) {
      options[HTTP2_HEADER_CONTENT_TYPE] = 'application/json';
    } else if (isParsable === false) {
      options[HTTP2_HEADER_CONTENT_TYPE] = contentType;
    }

    // Connect to the target service
    const server = http2.connect(targetUrl, {
      protocol: 'http2'
    });

    const serverStream = server.request(options);

    //console.log('Forward Headers:', clientHeaders);


    console.log(`Connected to the ${targetUrl} service, waiting for response...`);

    // Handle errors in the server stream
    serverStream.on('error', (error) => {
      console.error('Error in serverStream:', error);
    });

    // Forward client body to server
    if (hasBody) {
      if (isParsable) {
        serverStream.write(JSON.stringify(forwardRequestBodyJson));
        console.log(`Writing JSON Body, waiting for response...`);
        serverStream.end();
      } else {
        // Write the body data directly to the server stream
        //const asciiEncodedBody = Buffer.from(requestBody, 'ascii');
        //serverStream.write(asciiEncodedBody);
        requestBodyBinary.forEach((chunk) => {
          serverStream.write(chunk);
        });
        console.log(`Writing Body Binary, waiting for response...`);
        serverStream.end();
      }
    } else {
      console.log(`No Body Body, waiting for response...`);
    }

    // Event handler for the server's response
    serverStream.on('response', (serverHeaders) => {
      // Check if the Location header exists
      if (serverHeaders['location']) {
        // Get the original Location value
        const originalLocation = serverHeaders['location'];

        // Replace the string using regular expression and the replace() method
        const modifiedLocation = originalLocation.replace(/snet\.tuberlin:80/g, 'snet.tuberlin:9999');

        // Update the Location field in the serverHeaders object
        serverHeaders['location'] = modifiedLocation;
      }

      const responseBodyChunks = [];

      serverStream.on('data', (chunk) => {
        responseBodyChunks.push(chunk);
      });

      serverStream.on('end', () => {
        const responseBody = Buffer.concat(responseBodyChunks).toString();
        const modifiedBody = responseBody.replace(/snet\.tuberlin:80/g, 'snet.tuberlin:9999');
        const modifiedBodyLength = Buffer.byteLength(modifiedBody);

        // Update the Content-Length header
        serverHeaders['content-length'] = modifiedBodyLength.toString();

        // Respond with the modified headers
        clientStream.respond(serverHeaders);

        // Write the modified body to the client stream
        clientStream.write(modifiedBody, 'utf8', () => {
          clientStream.end();
        });

        // Log the outgoing response headers
        console.log('======================== Outgoing Response Headers ========================');
        console.log('Headers:', serverHeaders);
        console.log('===========================================================================');
        console.log();
        // Log the body of the response
        console.log('======================= Outgoing Response Body ============================');
        console.log(modifiedBody);
        console.log('===========================================================================');
        console.log();
      });


    });


    clientStream.on('end', () => {
      server.close();
    });

  });

});

// Start the proxy server on port 9999
proxy.listen(9999);

console.log("Proxy server started and listening on port 9999.");